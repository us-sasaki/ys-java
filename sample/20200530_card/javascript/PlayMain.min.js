const startBridge=function(){const sim=document.getElementById("bridge-simulator");sim.innerHTML='\n    <div id="modal-overlay"></div>\n    <div id="modal-content">\n        <table class="full">\n            <tr><td style="font-weight:bold; vertical-align: middle;">　問題を選んでね！　<img src="images/sumire_icon.gif" height="100%" style="vertical-align: middle;"></img></td></tr>\n            <tr><td>\n                <table class="full"><tr><td>\n                <select name="select"></select>\n                </td>\n                <td><input type="button" value="開始する" id="startButton"></td></tr>\n                </table>\n            </td></tr>\n            <tr><td><input type="button" value="今のプレイを自動再生する" id="videoButton"></td></tr>\n            <tr><td><input type="button" value="同じハンドをもう一度プレイする" id="replayButton"></td></tr>\n        </table>\n\t</div>\n\t<canvas id="canvas" width="640" height="480"></canvas>\n',(async()=>{const m=new PlayMain("canvas");for(;;)await m.start()})()};class PlayMain{static VUL=[Board.VUL_NONE,Board.VUL_NS,Board.VUL_EW,Board.VUL_BOTH,Board.VUL_NS,Board.VUL_EW,Board.VUL_BOTH,Board.VUL_NONE];static BOARDS=4;canvasId;field;board;players;handno;contractString;problems;sumire;quit;dd;textWindow;dialog;confirmDialog;exitSignal;isPractice;totalScore;boardNum;constructor(canvasId){this.canvasId=canvasId,this.problems=[],this.dialog=new SelectDialog,this.field=new Field(this.canvasId),this._placeQuitButton_(),this._placeDDButton_(),this.totalScore=0,this.boardNum=0;try{problem.forEach(p=>this.addProblem(Problem.regular(p)))}catch(e){this.isPractice=!0,!e instanceof ReferenceError&&console.log(e)}}addProblem(p){p.isValid()&&this.problems.push(p)}_placeQuitButton_(){this.quit=new Button(this.field,"中断"),this.quit.setBounds(540,30,80,24),this.field.add(this.quit),this.quit.setListener(()=>{this.isPractice?window.confirm("これまでのプレイ結果を破棄して中断しますか？")&&(this.totalScore=0,this.boardNum=-1,this.field.interrupt()):window.confirm("このボードを破棄して中断します")&&this.field.interrupt()})}_placeDDButton_(){const dd=new Button(this.field,"ダブルダミー");dd.doubleDummy=!1,this.field.add(dd),dd.setBounds(540,58,80,24),dd.setListener(()=>{this.board.status==Board.PLAYING&&(dd.doubleDummy=!dd.doubleDummy,this._ddSet_(dd.doubleDummy))}),this.dd=dd}_ddSet_(doubleDummy){this.dd.doubleDummy=doubleDummy,this.dd.caption=doubleDummy?"通常に戻す":"ダブルダミー",this.board.getHand(Board.EAST).turn(doubleDummy),this.board.getHand(Board.WEST).turn(doubleDummy),this.field.draw()}_placeTextButton_(){this.textWindow=new Button(this.field,"テキスト表示"),this.field.add(this.textWindow),this.textWindow.setBounds(540,86,80,24),this.textWindow.setListener(()=>{window.confirm(this.board.toText())})}async start(){if(this.field.draw(),this.isPractice)this.totalScore=0,this._makeRandomHand_(),this._ddSet_(!1);else{const titles=[];this.problems.forEach(prob=>titles.push(prob.title)),this.dialog.setPulldown(titles);const disabled=!this.board;this.dialog.replayButton.disabled=disabled,this.dialog.videoButton.disabled=disabled||this.board.status!==Board.SCORING;const result=await this.dialog.show();"video"==result?(this._makeVideohand_(),this._ddSet_(!0),this.boardNum=(this.boardNum+PlayMain.BOARDS-1)%PlayMain.BOARDS):"replay"==result?(this._makeLasthand_(),this._ddSet_(!1),this.boardNum=(this.boardNum+PlayMain.BOARDS-1)%PlayMain.BOARDS):(this.handno=parseInt(result.substring(4)),this._makeNewhand_(),this._ddSet_(!1))}CardImageHolder.setBackImage(this.boardNum%4),this.field.add(this.board),this.board.setPosition(0,0),this.board.setDirection(0),this.field.draw(),await this.main(),this.field.pull(this.board),this.boardNum++,this.boardNum===PlayMain.BOARDS&&(this.totalScore=0,this.boardNum=0)}_makeNewhand_(){const prob=this.problems[this.handno];this.board=new Board(1),this.board.name=prob.title,this._setPlayers_(prob);const hands=prob.createHands();this.board.deal(hands),this.board.setContract(prob.contract,Board.SOUTH)}_setPlayers_(prob){const thinker=this.isPractice?problem:prob.thinker;this.players=[],this.players[Board.NORTH]=new RandomPlayer(this.board,Board.NORTH),this.players[Board.SOUTH]=new HumanPlayer(this.board,this.field,Board.SOUTH),thinker&&"DoubleDummyPlayer"==thinker?"DoubleDummyPlayer"==thinker?(this.players[Board.EAST]=new ReadAheadPlayer(this.board,Board.EAST),this.players[Board.WEST]=new ReadAheadPlayer(this.board,Board.WEST,prob.openingLead)):(this.players[Board.EAST]=new RandomPlayer(this.board,Board.EAST),this.players[Board.WEST]=new RandomPlayer(this.board,Board.WEST)):(this.players[Board.EAST]=new SimplePlayer2(this.board,Board.EAST),this.players[Board.WEST]=new SimplePlayer2(this.board,Board.WEST,prob.openingLead))}_makeVideohand_(){const oldBoard=this.board;this.board=new Board(1),this.board.name=oldBoard.name,this.players=[];for(let i=0;i<4;i++)this.players.push(new VideoPlayer(this.board,oldBoard,i));const hands=BridgeUtils.calculateOriginalHand(oldBoard);this.board.deal(hands),this.board.setContract(oldBoard.getContract(),oldBoard.getDeclarer())}_makeLasthand_(){const prob=this.problems[this.handno],oldBoard=this.board;this.board=new Board(1),this.board.name=oldBoard.name,this._setPlayers_(prob);const hands=BridgeUtils.calculateOriginalHand(oldBoard);this.board.deal(hands),this.board.setContract(oldBoard.getContract(),oldBoard.getDeclarer())}_makeRandomHand_(){const prob=Problem.random(this.boardNum);this.problems=[prob],this.handno=0,this.board=new Board(1),this.board.name=prob.title,this._setPlayers_(prob);const hands=prob.createHands();this.board.deal(hands),this.board.setContract(prob.contract,Board.SOUTH)}async explain(){const prob=this.problems[this.handno];this.sumire=new Sumire(this.field,prob.description),this.contractString=prob.getContractString(),await this.sumire.animate(Sumire.NORMAL)}async mainLoop(){for(this.dd.doubleDummy&&(this.board.getHand(Board.EAST).turn(!0),this.board.getHand(Board.WEST).turn(!0));;){this.field.spot=this.board.getTurn(),this.field.draw();let c=null;for(;null===c;)c=await this.players[this.board.getPlayer()].play();if(await this.board.playWithGui(c),this.field.draw(),this.board.status===Board.SCORING)break}}async displayScore(){this.field.spot=-1,this.field.draw(),await this.field.sleep(500);const original=BridgeUtils.calculateOriginalHand(this.board);for(let i=0;i<4;i++){const hand=this.board.getHand(i);for(let j=0;j<original[i].children.length;j++){const c=original[i].children[j];hand.add(c)}hand.turn(!0)}this.board.selfLayout(),this.board.getHand().forEach(hand=>{hand.arrange(),hand.selfLayout()});let msg="結果："+this.contractString+"  ",msg2;const win=BridgeUtils.countDeclarerSideWinners(this.board),up=win-this.board.getContract().level-6,make=win-6;up>=0?(msg+=make+"メイク",msg2="おめでとう！！"):(msg+=-up+"ダウン",msg2=this.isPractice?"残念。":"残念。もう一度がんばって！");const score=Score.calculate(this.board,Board.SOUTH);msg+="("+win+"トリック)\nN-S側のスコア："+score+"\n",this.isPractice&&(this.totalScore+=score,msg+="スコア累積:"+this.totalScore),msg+="\n"+msg2,this.sumire=new Sumire(this.field,msg),up>=0?await this.sumire.animate(Sumire.DELIGHTED):await this.sumire.animate(Sumire.SAD),this.field.draw(),this.board.getHand().forEach(h=>{for(;h.children.length>0;)h.pull()})}async main(){try{await this.explain(),await this.mainLoop(),await this.displayScore(),this.field.pull(this.board)}catch(e){if(!(e instanceof QuitInterruptException))throw e;console.log("quit inspected"),this.field.spot=-1,this.field.draw()}}}class Problem{title;contract;hands;description;openingLead;thinker;getContractString(){return this.contract?this.contract.toString().substring(1,7):"null"}isValid(){return!0}static regular(problem){let p=new Problem;p.title=problem.title,p.description=problem.description,p.openingLead=problem.openingLead,p.thinker=problem.thinker;const level=parseInt(problem.contract[0]);let kind=Bid.BID;problem.contract.endsWith("XX")?kind=Bid.REDOUBLE:problem.contract.endsWith("X")&&(kind=Bid.DOUBLE);const s=problem.contract.substring(1);let suit=Bid.CLUB;return s.startsWith("D")&&(suit=Bid.DIAMOND),s.startsWith("H")&&(suit=Bid.HEART),s.startsWith("S")&&(suit=Bid.SPADE),s.startsWith("NT")&&(suit=Bid.NO_TRUMP),p.contract=new Bid(kind,level,suit),p.hands=[problem.n,problem.e,problem.s,problem.w],p}createHands(){const pile=Packet.provideDeck(),hs=[];for(let i=0;i<4;i++)hs.push(new Packet);for(let i=0;i<4;i++)Problem.draw(pile,hs[i],this.hands[i]);if(pile.children.length>0){pile.shuffle();for(let i=0;i<4;i++)for(let j=hs[i].children.length;j<13;j++)hs[i].add(pile.pull())}return hs.forEach(h=>h.arrange()),hs}static draw(pile,hand,str){if(!str)return;let suit=Card.SPADE;for(let i=0;i<str.length;i++){const c=str.charAt(i);"S"==c?suit=Card.SPADE:"H"==c?suit=Card.HEART:"D"==c?suit=Card.DIAMOND:"C"==c?suit=Card.CLUB:"K"==c?hand.add(pile.pull(suit,Card.KING)):"Q"==c?hand.add(pile.pull(suit,Card.QUEEN)):"J"==c?hand.add(pile.pull(suit,Card.JACK)):"T"==c?hand.add(pile.pull(suit,10)):"A"==c?hand.add(pile.pull(suit,Card.ACE)):c>="2"&&c<="9"&&hand.add(pile.pull(suit,parseInt(c)))}}static random(boardNum,seed){seed&&ReproducibleRandom.setSeed(seed);const p=new Problem,pile=Packet.provideDeck();pile.shuffle(),p.hands=[];for(let i=0;i<4;i++)p.hands.push(new Packet);Packet.deal(pile,p.hands,0);for(let i=0;i<4;i++)p.hands[i].arrange();const a=Problem.calculateAttributes(p.hands);let maxNSTricks=-1,maxDenom=-1,minNSTricks=1400,minDenom=-1;for(let i=0;i<5;i++)a.trick[i]>maxNSTricks&&(maxNSTricks=a.trick[i],i<4&&(maxDenom=i+1)),a.trick[i]<minNSTricks&&(minNSTricks=a.trick[i],i<4&&(minDenom=i+1));let NSorEW=-1,denomination,declarer;console.log("min "+minNSTricks+"  max "+maxNSTricks),maxNSTricks-minNSTricks<=100?(denomination=Bid.NO_TRUMP,NSorEW=a.trick[Bid.NO_TRUMP]>650?0:1):maxNSTricks>1300-minNSTricks?(NSorEW=0,denomination=maxDenom):(NSorEW=1,denomination=minDenom),declarer=denomination===Bid.NO_TRUMP?a.hcp[NSorEW]>a.hcp[NSorEW+2]?NSorEW:NSorEW+2:a.count[NSorEW][denomination-1]>a.count[NSorEW+2][denomination-1]?NSorEW:NSorEW+2,a.pts=Problem.calcPoints(denomination,declarer,NSorEW,a);const totalPt=a.pts[NSorEW]+a.pts[NSorEW+2];let level;console.log("Total Point : "+totalPt),level=totalPt>36?7:totalPt>32?6:totalPt>29?5:totalPt>26?4:totalPt>23?3:totalPt>21?2:1;let kind=Bid.BID,tr=Math.floor(a.trick[denomination-1]/100);tr<7&&(tr=13-tr),level+5>tr&&(kind=Bid.DOUBLE),p.contract=new Bid(kind,level,denomination);for(let i=0;i<(declarer-Board.SOUTH+4)%4;i++){const tmp=p.hands[0];for(let j=0;j<3;j++)p.hands[j]=p.hands[j+1];p.hands[3]=tmp}for(let i=0;i<4;i++)p.hands[i]=p.hands[i].toString();switch(p.description="あなたの "+p.getContractString()+" よ。\n切り札は",denomination){case Bid.NO_TRUMP:p.description+="ありません。";break;case Bid.SPADE:p.description+="スペード、";break;case Bid.HEART:p.description+="ハート、";break;case Bid.DIAMOND:p.description+="ダイアモンド、";break;case Bid.CLUB:p.description+="クラブ、";break;default:p.description+="なんでしょう。"}return p.description+="\n13トリックのうち、"+(level+6)+"トリック以上とってね",p.title="Board "+(boardNum+1),p}static calculateAttributes(hands){const a={count:[]};for(let i=0;i<4;i++){a.count[i]=[];for(let suit=1;suit<5;suit++)a.count[i][suit-1]=hands[i].countSuit(suit)}a.hcp=[];for(let i=0;i<4;i++)a.hcp[i]=BridgeUtils.countHonerPoint(hands[i])[0];a.trick=[];for(let denomination=1;denomination<6;denomination++){const b=new Board(1);b.deal(hands),b.setContract(new Bid(Bid.BID,1,denomination),Board.SOUTH);const ob=new OptimizedBoard(b);a.trick[denomination-1]=1300-ob.calcApproximateTricks(),console.log(" denom : "+denomination+"  Tricks : "+a.trick[denomination-1])}return a}static calcPoints(denomination,declarer,NSorEW,a){const pts=[];for(let i=NSorEW;i<4;i+=2)pts[i]=a.hcp[i];if(denomination!==Bid.NO_TRUMP){for(let i=NSorEW;i<4;i+=2)for(let suit=1;suit<5;suit++){if(suit===denomination)continue;const cnt=a.count[i][suit-1];cnt>4&&(pts[i]+=cnt-4)}const fit=a.count[NSorEW][denomination-1]+a.count[NSorEW+2][denomination-1];fit>8&&(pts[NSorEW]+=Math.floor(3*(fit-8)/2));const dummy=(declarer+2)%4,dummyTrumps=a.count[dummy][denomination-1];for(let suit=1;suit<5;suit++){const cnt=a.count[dummy][suit-1];switch(cnt){case 0:pts[dummy]+=Math.min(5,3*dummyTrumps);break;case 1:pts[dummy]+=Math.min(3,3*(dummyTrumps-1));break;case 2:pts[dummy]+=Math.min(1,3*(dummyTrumps-2))}}}return pts}}class SelectDialog{modalContent;modalOverlay;select;startButton;videoButton;replayButton;constructor(titles){if(this.modalContent=document.getElementById("modal-content"),this.modalOverlay=document.getElementById("modal-overlay"),!this.modalContent||!this.modalOverlay)throw new Error("html error. without modal-content or modal-overlay");const s=document.getElementsByName("select");if(1!=s.length)throw new Error("html doesn't have select");this.select=s[0],this.startButton=document.getElementById("startButton"),this.videoButton=document.getElementById("videoButton"),this.replayButton=document.getElementById("replayButton")}setPulldown(titles){for(;this.select.firstChild;)this.select.removeChild(this.select.firstChild);for(let i=0;i<titles.length;i++){const opt=document.createElement("option");opt.setAttribute("value","prob"+(i+1)),opt.innerHTML=titles[i],this.select.appendChild(opt)}}show(){let startListener,videoListener,replayListener;return new Promise(res=>{startListener=()=>{res("prob"+this.select.selectedIndex)},videoListener=()=>{res("video")},replayListener=()=>{res("replay")},this.startButton.addEventListener("click",startListener),this.replayButton.addEventListener("click",replayListener),this.videoButton.addEventListener("click",videoListener),this.modalContent.style.display="inline",this.modalOverlay.style.display="inline"}).then(val=>new Promise(res=>{this.startButton.removeEventListener("click",startListener),this.videoButton.removeEventListener("click",videoListener),this.replayButton.removeEventListener("click",replayListener),this.modalContent.style.display="none",this.modalOverlay.style.display="none",res(val)}))}}class Sumire extends Entity{static NORMAL=0;static DELIGHTED=1;static SAD=2;static FONT="normal 14px SanSerif";static Y_STEP=20;static MSG_COLOR="rgb(255, 255, 200)";static BACK_COLOR="rgba(200, 255, 200, 0.5)";field;lines;picNumber;face;x0;y0;width;height;mw;mh;xp;yp;constructor(field,msg){super(),this.field=field,this.lines=msg.split("\n");const lines=this.lines.length,ctx=field.ctx;ctx.font=Sumire.FONT,this.width=0;for(let i=0;i<lines;i++)this.width=Math.max(this.width,ctx.measureText(this.lines[i]));this.width+=20,this.height=Sumire.Y_STEP*lines+20,this.setBounds(140,120,360,240),this.x0=170,this.y0=Math.floor(102+Sumire.Y_STEP+100-Sumire.Y_STEP*lines*2/3);const msgy0=Math.floor(200-Sumire.Y_STEP*lines*2/3);this.mw=340,this.mh=Sumire.Y_STEP*lines+20,this.xp=[this.x0-20,this.x0-20+this.mw,this.x0-20+this.mw,410,405,390,this.x0-20],this.yp=[msgy0,msgy0,msgy0+this.mh,msgy0+this.mh,msgy0+this.mh+10,msgy0+this.mh,msgy0+this.mh],this.picNumber=0}draw(ctx){ctx.fillStyle=Sumire.BACK_COLOR,ctx.fillRect(this.x,this.y,this.w,this.h),ctx.strokeStyle="rgb(0,0,0)",ctx.fillStyle=Sumire.MSG_COLOR,ctx.beginPath(),ctx.moveTo(this.xp[0],this.yp[0]);for(let i=1;i<this.xp.length;i++)ctx.lineTo(this.xp[i],this.yp[i]);ctx.closePath(),ctx.fill(),ctx.stroke(),ctx.fillStyle="rgb(0,0,0)",ctx.font=Sumire.FONT;let y=this.y0;for(let i=0;i<this.lines.length;i++)ctx.fillText(this.lines[i],this.x0,y),y+=Sumire.Y_STEP;ctx.drawImage(CardImageHolder.SUMIRE[this.picNumber],400,260)}async animate(face){this.field.add(this),this.face=face;try{for(;;)if(this.picNumber^=this.face,this.field.draw(),this.picNumber>0){if(await this.field.waitClick(500))break}else if(await this.field.waitClick(1e3))break}catch(e){throw e instanceof QuitInterruptException&&this.field.pull(this),e}this.field.pull(this)}}