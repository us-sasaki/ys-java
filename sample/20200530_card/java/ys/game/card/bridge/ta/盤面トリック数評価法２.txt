＜概要＞

先読みせずに、取れるトリック数の概算を出します。

まず、各スートで、
連続して頭から取れるトリック数＝クイックウィナー数QW(suit)
を出します。QWはエスタブリッシュとアナードロップによる
プロモートを考慮した値です。プロモートのケースをきちんと計算するには、calcQW関数を２回行うことが必要な場合もあります。

ブロックの条件を少し変え、リード権の手に０枚の場合はブロックしているとみなし、ＱＷ＝shorterLength＝０となります。

ノートランプコントラクトの場合、

各スートのクイックウィナーQW(NSorEW, suit)枚をすべてキャッシュした場合を考え、それによるエスタブリッシュ（オポーネントのカードがすべてなくなった場合）による増加分と、第２位のアナードロップによる第３位のカードの昇格（プロモート）、さらにそれによるエスタブリッシュまでを評価し、QW値を確定する。

ノートランプでは必ずXs(NSorEW, suit)＝QWとなる。
すべてのスートについてXs（NSorEW, suit)を合計しX（NSorEW) とする。

スーツコントラクトの場合、

トランプスートの場合、QW(trump）はすぐに切り札狩りできるトリック数を意味します。
まず、トランプスートのＱＷ値を求めます。

サイドスートのＸｓはラフの効果を考えて目減りするので、切り札狩りをしてからサイドスートを出すものと考えて次のように求めます。切り札のトップウィナーＱＷ(trump)枚より１枚以上トランプを多く持っているオポーネントのそのスート枚数＝Ｍとすると、
Xs(suit)＝Min（QW（suit),  Ｍ）
とする。
ＱＷの計算の途中、Ｍを上回った時点で中止してＸｓ＝Ｍとしてもよい。（スピードアップのため）

トランプスートのＸｓは、ＱＷ値とは関係なく、次のように計算する。
totalwinners＝０のとき、
　　　｛
　　　Xs＝(自分のlongerLength-オポ側のlongerLength)(正のときのみ加える）+（第２位のカードの枚数－オポの第１位の枚数）(この値が負の場合は次の項を加えてから判断）＋（第４位－オポの第３位）(負の場合は次の項を加えてから判断）＋（第６位－第５位）……でリターン
　　　//↑の解説
　　　自分とパートナーの手にあるカードを合わせてランク順に並べ、上からMin（longerLength枚、オポ側longerLength枚）を抽出。オポ側もあわせて同枚数抽出。

（例１）    ８
ＡＫ７４　　　　　　　Ｊ５
　　　　　ＱＴ９６３２

(自分のlongerLength-オポ側のlongerLength)＝６－４＝２＞０なので
まずこれをＸｓに加えて、Ｘｓ＝２

こちら側のlongerLength=6、相手側のlongerLength=4、小さい方は４。
自分側…ＱＴ９８６３２の上から４枚であるＱＴ９８を抽出
オポ側…ＡＫＪ７５４の上から４枚であるＡＫＪ７を抽出
これを分類すると
第１位…（オポ）ＡＫ（２枚）
第２位…（自分）Ｑ（１枚）
第３位…（オポ）Ｊ（１枚）
第４位…（自分）Ｔ９８（３枚）
第５位…（オポ）７（１枚）
第６位…（自分）なし（０枚）
まず、第２位ー第１位＝（１－２）＝－１＜０なのでこの時点では加えない。
マイナスのときはさらに次の項を加えて正になるか判定する。
（第２位ー第１位）＋（第４位－第３位）＝（１－２）＋（３－１）＝－１＋２＝１＞＝０なのでここでこの１をＸｓに加える。Ｘｓ＝２＋１＝３
正になってＸｓに加えたら、和をリセットして次の項は単独で正負を判定、
（第６位－第５位）＝（０－１）＝－１なのでこれは加えない。ここで終了。
結局、Ｘｓ＝３が評価値となる。
　　　｝

トランプスートでtotalwinners > 0のとき、
　　　{
　　　Xs＝ＱＷ(trump)または、
      Xs＝(自分のlongerLength-オポ側のlongerLength)(正のときのみ加える）＋第１位の枚数＋（第３位のカードの枚数－オポの第２位の枚数）(この値が負の場合は次の項を加えてから判断）＋（第５位－オポの第４位）(負の場合は次の項を加えてから判断）……でリターン
     //やり方はtotalwinners=0のケースと同様。
     の大きい方。
     
     上の例をオポ側から見るとtotalwinners=２＞０
     (自分のlongerLength-オポ側のlongerLength)＝４－６＝－２＜０なので加えない。
     抽出するカードは同じになる。
     第１位＝２をまず加え、Ｘｓ＝２
     第３位－第２位＝１－１＝０＞＝０、加えてリセット。Ｘｓ＝２。
     第５位－第４位＝１－３＝－２、負なので加えず。
     となるので結局Ｘｓ＝２となる
　　　｝


オポーネント側の評価については、変更なし。
それぞれのオポの手にリード権があるとした場合の評価のうち
大きい方＝Max(X(opp1),X(opp2))とし、

最終評価値は、変更なし。
X（NSorEW) ＞limitTricks-Max(X(opp1),X(opp2))の場合
T=X（NSorEW) 、
それ以外の場合、
T=（X（NSorEW) ＋（limitTricks-Max(X(opp1),X(opp2))））/２
を返す。


以下プログラムのコードに沿って詳しく書く。

新しい変数QW (suit) : int …各スートのクイックウィナー
＝ブロック等も考慮して頭からキャッシュできるトリック数
以下QW、及びXsの求め方

スーツコントラクトの場合は
切り札スートのＱＷ（trump)を一番先に求め、トランプスートの最終的に確定したQW(trump)値をQWTに対し、

int Ｍ＝Min( オポーネントのトランプスートの枚数＞QWTとなるオポーネントの持っているそのsuitの枚数 ）を先に計算しておき、これをサイドスートのQW（suit)の上限とする。
ただし両オポーネントのトランプスートの枚数＜＝QWT
であれば、ＱＷに上限はない（Ｍ＝１３にでもしておくとよい）


以下、ＱＷ値を求める手続き関数（旧Ｘｓを求める部分の書き直し） 

calcQuickWinner(int NSorEW int suit) （仮称）
Xsを求める際に必要となる場合わけを行う。仮に戻り値は"block"、"ruff"等の文字列にしている。
以前のlongerLength,lowestCardOfShorterSuitなどの他に、こちらにウィナーがあるときはオポーネントの第２位のカード、ない時は第１位と第３位のカード、リード権の位置、上記のＭ（トランプスートでの確定ＱＷ値からもとめたサイドスートＱＷの上限値）を参照する。


//（Ａ）ブロック、オーバーテイク、オーバーテイク不要の３種類に分別する

//（Ａ）①ブロック（短いスートがすべてウィナーで、それ以外のウィナーをキャッシュできない場合）
//エスタブリッシュ等でQW値が増えることはない

// ブロック条件：
if （（shorterLength＞０)
     ＆(lowestCardOfShorterSuitがウィナーカード)
     ＆(rankOf(lowestCardOfShorterSuit)＞rankOf(highestCardOfLongerSuit)）
     ＯＲ (リード権のある手のスート枚数＝０) ） //今回追加した条件  
{ 　　　//"block"
 ＱＷ(suit)=shorterLength;
 ノートランプの場合
 Xs＝ＱＷ(suit)でリターン
 スーツコントラクトのサイドスートは、
 Xs＝Min（Ｍ、ＱＷ(suit))でリターン
 　　　｝

else
{
　//（Ａ）②ウィナーをオーバーテイクすればすべてキャッシュできる場合。
　//エスタブリッシュ等でQW値が増える場合を含む

　//オーバーテイク条件
　if(（shorterLength＞０）＆（lowestCardOfShorterSuitがウィナー）)
　　　//ブロックに入っていないので、
　　　//lowestCardOfShorterSuit＜  highestCardOfLongerSuit
　　　//のはず……オーバーテイクする
　{
　　ＱＷ(suit):=totalWinners －１
　　（B)にすすむ
  }
　else
　//（Ａ）③オーバーテイク不要ですべてのウィナーをキャッシュできる場合。
　//エスタブリッシュ等でQW値が増える場合が含まれる
 // (shorterLength＝０)または(lowestCardOfShorterSuitがウィナーでない)）のとき
　//リード権のないほうが０枚のケースが入る
　{
　　ＱＷ(suit):=totalWinners
　　（B)にすすむ
　｝
｝
//（Ａ）終わり

//（Ｂ）・・・（Ａ）②と（Ａ）③ ブロックしない場合  のつづき
　　if （QW(suit)＝０） 
       ＯＲ（{オポ１が第２位のカードを１枚以上持っていて、スート枚数が＞QW(suit)｝
       ＯＲ｛オポ２が第２位のカードを１枚以上持っていて、スート枚数が＞QW(suit)｝）
       //ＱＷ枚をキャッシュしても第２位のカードが１枚以上オポの手に残る場合で、エスタブリッシュもアナードロップも起こらないケース。
　　{
　　　ノートランプの場合
　　　Xs＝QW(suit)でリターン

　　　スーツコントラクトのサイドスートは、
　　　Xs＝Min（Ｍ、QW(suit))でリターン

　　　}

　　else  //（QW(suit)＞０）
　　　　　// ＆（{もしオポ１が第２位のカードを１枚以上持っているなら、スート枚数は<=QW(suit)｝
　　　　　//＆（{もしオポ２が第２位のカードを１枚以上持っているなら、スート枚数は<=QW(suit)｝
　　　　　//第２位のカードをすべて叩き落せるケースで、丸々エスタブリッシュまたはアナードロップのどちらか
　　　　　//もともとすべてウィナーでない限り、最低１トリックが昇格してウィナーになりＱＷ＋１枚キャッシュできる
　　　　　//「どちらかのオポーネントのスート枚数がＱＷ枚以下」が成り立っている

　　{
　　　if（ (QW(suit)＋１>= longerLength)　　//１トリックのプロモートによってウィナーが十分多くなる場合（もともと十分だった場合も含まれる）
　　　　　　ＯＲ（（オポ１のsuitの枚数 ＜＝ QW(suit)＋１)＆(オポ２のsuitの枚数 ＜＝ QW(suit)＋１））　　//  昇格分を含めウィナーを叩けば両オポ０枚になり丸々エスタブリッシュする場合

　　　{　　　"longerLength"
　　　　QW(suit)=longerLength
　　　　ノートランプの場合
　　　　Xs＝QW(suit)でリターン
　　　　スーツコントラクトのサイドスートは、
　　　　Xs＝Min（Ｍ、QW(suit))でリターン
　　　}

　　　else　　　　//QW＋１枚のキャッシュによっても、片方のオポの手に第４位以下のカードが１枚以上残りエスタブリッシュしない状況。第３位のカードが何枚キャッシュできるか実際にやってみる必要がある。
    　{
    　　if （（スーツコントラクトである）＆（suit!=trump）＆（QW(suit)＋１＞＝Ｍ））
    　　{　　"ruff" 
　　　　　　　　Xs＝Mでリターン　　　　　}

　　　　else 　//もう一度calcＱＷ関数を繰り返す必要がある。
　　　　{"again"のフラグをつけて返す。
　　　　　//ＱＷ枚をキャッシュしたカード状況を作り、もう一度計算する。 　｝
　　　｝
//（Ｂ）終わり
｝

ここで、calcQuickWinner関数終了。


"again"のフラグの場合だけは
スート内容を次のように変更してもう一度calcQuickWinner関数で
ＱＷ値、Ｘｓ値を求める必要がある。
ここではＱＷ＝totallwinnersまたはtotallwinners－１になっているが、
第１位のカード（winner)をＱＷ回ですべてキャッシュ（ブロックしていないので可能）したカード状態を次のように作成する。

・もともとスート枚数がＱＷ枚より少ない手は０枚になる。
・オポーネントは下からＱＷ枚を捨て去る。
・自分たち側のwinnerはすべて消す。winnerの枚数がＱＷ枚に満たない手は、残る枚数を下から捨て去る。
・リード権は０枚でない方にある。

例１：
            Ｊ６４
９８７　　　　　　     Ｑ
　　　　　ＡＫＴ５３２

ＱＷ＝２で、"again"の状況に当てはまる。

この場合、ＡＫの２枚キャッシュしたあとの状態とは
　　         Ｊ
９　　　　　　　　　　　－
　　 　　　T５３２

例２：
            ＱＪＴ
９８７６４　　　　　　    －
　　　　　ＡＫ５３２

オーバーテイクに当てはまり、
ＱＷ＝５－１＝４、"again"状況に当てはまる。

この場合、ＱＷ＝４枚をキャッシュしたあとの状態とは
　　         －
９　　　　　　　　　　　－
　　 　　　５


//"again"状況では、オポーネントの１人だけが必ず０枚になること、ＱＷ枚のプレイにより、オポーネントのウィナーが叩き落され、さっきまでウィナーでなかったカードがウィナーとして昇格することに注意。

この状態でlongerLength等を計算し直し、もう一度calcQuickWinner関数を実行する。今度はプロモート状況に陥ることはありえず、必ず、ＱＷ値、Ｘｓ値が確定する。

この２度目のＸｓ値に、最初のＱＷ値（totalwinners またはtotalwinners －１）を加算したものを最終的なＱＷ値、Ｘｓ値として確定する。



（Ｃ）（Ｄ）は（Ａ）（Ｂ）に組み込まれたので削除する。
