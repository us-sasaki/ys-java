import java.util.*;
import java.io.*;

/**
 * 複数回のディレクトリ内ファイルサイズ情報を元に沢山使っているファイルを
 * 抽出する。
 */
public class FileList {
	public static int DEPTH = FileLister.MAX_DEPTH;
	
	/** 各種処理用に便利な値を追加. keyはpath */
	class FileEntry {
		String		path;
		int			level;		// 深さ
		boolean		isDirectory; // ディレクトリか？
		List<Long>	sizeList;	// 過去のサイズ履歴
		long		size;
		long		increase;	// 直近の増分
		String		owner;		// ファイル所有者
	}
	
	List<FileEntry> list;
	int sizeListCount;
	
/*-------------
 * constructor
 */
	/**
	 * 空の FileList を作ります。
	 */
	public FileList() {
		list = null;
		sizeListCount = 0;
	}
	
/*------------------
 * instance methods
 */
	/**
	 * FileMapper の結果を入力として、FileEntry の List を構築します
	 *
	 * readFile しかデバッグしてないので初めて使うときは注意！！
	 */
	public void set(Map<String, List<Long>> m) {
		if (list != null) throw new IllegalStateException("すでに値を保持しています");
		list = new ArrayList<FileEntry>();
		
		
		// map を FileEntry のリストに変換する
		int maxTokens = 0;
		for (String path : m.keySet()) {
			// FileEntry に変換する
			FileEntry entry = new FileEntry();
			
			String[] token = path.split(",");
			
			entry.level = Integer.parseInt(token[0]);
			String p = "";
			for (int i = 1; i <= DEPTH; i++) {
				if (token[i].equals("")) continue;
				if (i > 1) p = p + "\\";
				p = p + token[i];
			}
			entry.path = p;
			entry.isDirectory = false; // ちゃんと処理してない
			entry.sizeList = new ArrayList<Long>();
			
			boolean hasSize  = false;
			boolean hasOwner = false;
			int tokens = token.length;
			for (Long s : m.get(path)) {
				entry.sizeList.add(s);
				tokens++;
			}
			if (tokens > maxTokens) maxTokens = tokens;
			
			// 最後の成分が長さの場合、文字列の場合の両方を含むとエラー
			if (hasSize&&hasOwner) throw new NumberFormatException("フォーマットエラー");
			
			List<Long> l = entry.sizeList;
			entry.size	= l.get(l.size() - 1);
			entry.increase = entry.size - l.get(l.size() - 2);
			
			list.add(entry);
		}
		
		// isDirectory の設定
		// アルゴリズム
		//   同一のpath文字列を含む他の Entry があれば directory
		//   まず path について辞書式にならべるとすぐわかりそう
		list.sort(new PathOrder());
		makeup(); // sizeList の長さをそろえ、isDirectoryを設定
	}
	
	/**
	 * 試験用に作ったもの。今後はlistyyyyMMdd.csv 形式のものを呼ぶように変更
	 * ファイル名から、いつの情報かを取得する必要があるため。
	 * FileMapper も不要になりそう
	 *
	 * @deprecated
	 */
	public void readFile(String fname) throws IOException {
		if (list != null) throw new IllegalStateException("すでに値を保持しています");
		list = new ArrayList<FileEntry>();
		
		FileReader fr = new FileReader(fname);
		BufferedReader br = new BufferedReader(fr);
		
		int maxTokens = 0;
		while (true) {
			String line = br.readLine();
			if ( (line == null)||(line.equals("")) ) break;
			
			String[] token = line.split(",");
			
			// ファイルサイズが途中で切れることがあるため、最大値を取得
			if (token.length > maxTokens) maxTokens = token.length;
			
			// FileEntry に変換する
			FileEntry entry = new FileEntry();
			
			entry.level = Integer.parseInt(token[0]);
			String p = "";
			for (int i = 1; i <= DEPTH; i++) {
				if (token[i].equals("")) continue;
				if (i > 1) p = p + "\\";
				p = p + token[i];
			}
			entry.path = p;
			entry.isDirectory = false; // ちゃんと処理してない
			entry.sizeList = new ArrayList<Long>();
			
			boolean hasSize  = false;
			boolean hasOwner = false;
			
			for (int i = DEPTH+1; i < token.length; i++) {
				if (token[i].equals("")) token[i] = "0";
				try {
					entry.sizeList.add(Long.decode(token[i]));
					if (i == token.length - 1) hasSize = true;
				} catch (NumberFormatException e) {
					if (i == token.length - 1) {
						entry.owner = token[i];
						hasOwner = true;
					}
					else throw new NumberFormatException(e.getMessage());
				}
			}
			// 最後の成分が長さの場合、文字列の場合の両方を含むとエラー
			if (hasSize&&hasOwner) throw new NumberFormatException("フォーマットエラー");
			
			List<Long> l = entry.sizeList;
			entry.size	= l.get(l.size() - 1);
			if (l.size() == 1) {
				entry.increase = entry.size;
			} else {
				entry.increase = entry.size - l.get(l.size() - 2);
			}
			
			list.add(entry);
		}
		
		sizeListCount = maxTokens - MAX_DEPTH - 1;
		
		fr.close();
		br.close();
		// isDirectory の設定
		// アルゴリズム
		//   同一のpath文字列を含む他の Entry があれば directory
		//   まず path について辞書式にならべるとすぐわかりそう
		list.sort(new PathOrder());
		makeup(); // sizeList の長さをそろえ、isDirectoryを設定
	}
	
	public void addFile(String fname) throws IOException {
		if (list == null) list = new ArrayList<FileEntry>();
		
		FileReader		fr	= new FileReader(fname);
		BufferedReader	br	= new BufferedReader(fr);
		
		while (true) {
			String line = br.readLine();
			if ( (line == null)||(line.equals("")) ) break;
			
			String[] token = line.split(",");
			
			// まず path を生成する
			String p = "";
			for (int i = 1; i <= DEPTH; i++) {
				if (token[i].equals("")) continue;
				if (i > 1) p = p + "\\";
				p = p + token[i];
			}
			
			// FileEntry として追加
			// 同一の path を含む entry を探す(遅い全数探索)
			FileEntry entry = null;
			boolean newEntry = false;
			for (FileEntry fe : list) {
				if (fe.path.equals(p)) {
					entry = fe;
					break;
				}
			}
			if (entry == null) {
				// 新しい path
				entry = new FileEntry();
				list.add(entry); // entry の参照だけ先に登録、中身は以降変更
				
				entry.level = Integer.parseInt(token[0]);
				entry.path = p;
				entry.isDirectory = false; // ちゃんと処理してない
				entry.sizeList = new ArrayList<Long>();
				for (int i = 0; i < sizeListCount; i++) {
					entry.sizeList.add(0L);
				}
			}
			entry.sizeList.add(Long.decode(token[MAX_DEPTH + 1]);
			
			// increase は１つ前のものとの差分を取っているが、
			// 今後、指定できるようにする
			List<Long> l = entry.sizeList;
			entry.size	= l.get(l.size() - 1); // 最後(最新)のサイズ
			if (l.size() == 1) {
				entry.increase = entry.size;
			} else {
				entry.increase = entry.size - l.get(l.size() - 2);
			}
		}
		
		sizeListCount++;
		
		fr.close();
		br.close();
		
	}
	
	private void makeup() {
		for (FileEntry e : list) {
			int l = e.sizeList.size();
			for (int i = 0; i < sizeListCount - l; i++) {
				e.sizeList.add(new Long(0));
			}
			e.size = e.sizeList.get(e.sizeList.size() - 1);
		}
		FileEntry f = list.get(0);
		for (int i = 1; i < list.size(); i++) {
			FileEntry next = list.get(i);
			if (next.path.startsWith(f.path)) f.isDirectory = true;
			else f.isDirectory = false;
			f = next;
		}
	}
	
	public List<FileEntry> getList() {
		return list;
	}
	
	public List<FileEntry> selectLevel(int level) {
		if (list == null) throw new IllegalStateException("set または readFile によって値を格納してください");
		ArrayList<FileEntry> result = new ArrayList<FileEntry>();
		
		for (FileEntry f : list) {
			if (f.level == level) result.add(f);
		}
		return result;
	}
	
	public List<FileEntry> selectFile(boolean isFile) {
		if (list == null) throw new IllegalStateException("set または readFile によって値を格納してください");
		ArrayList<FileEntry> result = new ArrayList<FileEntry>();
		
		for (FileEntry f : list) {
			if (f.isDirectory != isFile) result.add(f);
		}
		return result;
	}
	
/*-------------
 * inner class
 */
	/**
	 * 長さ, 深さ, パス名 の順に並べる Comparator
	 */
	static class SizeOrder implements Comparator<FileEntry> {
		public int compare(FileEntry a, FileEntry b) {
			if (a.size > b.size) return 1;
			if (a.size < b.size) return -1;
			if (a.level != b.level) return a.level - b.level;
			return a.path.compareTo(b.path);
		}
		
		public boolean equals(FileEntry a, FileEntry b) {
			return ((a.size == b.size)&& // 早くて分解能が高い size でまず比較
						(a.level == b.level)&&
						(a.path.equals(b.path)) );
		}
	}
	
	/**
	 * 増分, 深さ, パス名 の順に並べる Comparator
	 */
	static class IncreaseOrder implements Comparator<FileEntry> {
		public int compare(FileEntry a, FileEntry b) {
			if (a.increase > b.increase) return 1;
			if (a.increase < b.increase) return -1;
			if (a.level != b.level) return a.level - b.level;
			return a.path.compareTo(b.path);
		}
		
		public boolean equals(FileEntry a, FileEntry b) {
			return ((a.increase == b.increase)&& // 早くて分解能が高い increase でまず比較
						(a.level == b.level)&&
						(a.path.equals(b.path)) );
		}
	}
	
	/**
	 * パス名 の辞書式順序で並べる Comparator
	 */
	static class PathOrder implements Comparator<FileEntry> {
		public int compare(FileEntry a, FileEntry b) {
			return a.path.compareTo(b.path);
		}
		
		public boolean equals(FileEntry a, FileEntry b) {
			return a.path.equals(b.path);
		}
	}
	
/*------
 * main
 */
	public static void main(String[] args) throws Exception {
		FileList a = new FileList();
		a.readFile("Merged20160516.csv");
		
		// 大きいファイルを20個表示
		List<FileEntry> list = a.selectFile(true);
		list.sort(new SizeOrder().reversed());
		int c = 0;
		for (FileEntry f : list) {
			System.out.println(f.path + "," + f.size);
			c++;
			if (c > 20) break;
		}
		
		// レベル1で増分の大きい順に表示
		List<FileEntry> l1 = a.selectLevel(1);
		l1.sort(new IncreaseOrder().reversed());
		for (FileEntry f : l1) {
			System.out.println(f.path + "," + f.increase + "," + f.size);
		}
		
		// レベル2で増分の大きい順に10個表示
		List<FileEntry> l2 = a.selectLevel(2);
		l2.sort(new IncreaseOrder().reversed());
		c = 0;
		for (FileEntry f : l2) {
			System.out.println(f.path + "," + f.increase + "," + f.size);
			c++;
			if (c > 10) break;
		}
		
		// レベル3で増分の大きい順に20個表示
		List<FileEntry> l3 = a.selectLevel(3);
		l3.sort(new IncreaseOrder().reversed());
		c = 0;
		for (FileEntry f : l3) {
			System.out.println(f.path + "," + f.increase + "," + f.size);
			c++;
			if (c > 20) break;
		}
		
		// 同じファイル疑惑を探す
		long lastSize = -1;
		String lastPath = "";
		String lastFile = "";
		c = 0;
		for (FileEntry f : list) {
			String p = f.path;
			try {
				String[] t = p.split("\\\\");
				if (lastFile.equals(t[t.length-1])) {
					System.out.println("-------------------------------------------");
					System.out.println(lastPath);
					System.out.println(f.path);
				}
				lastSize = f.size;
				lastPath = f.path;
				lastFile = t[t.length-1];
				c++;
				if (c > 20) break;
			} catch (Exception e) {
				System.out.println(e);
				System.out.println(p);
				break;
			}
		}
	}
	
}
